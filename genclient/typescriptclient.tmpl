// This file was automatically @generated by gentypescript

type apiSchemaCollection = {
{{- range . }}
  "{{ .MethodPath }}": {
    Request: {{ .Request.RenderRequest "    " }}
    Response: {{ .Response.RenderResponse "    " }}
  };
{{- end }}
}

type method = keyof apiSchemaCollection extends `${infer M} ${string}` ? M : never;
type methodPathsByMethod<M extends method> = Extract<keyof apiSchemaCollection, `${M} ${string}`>
type pathByMethod<MP extends string> = MP extends `${method} ${infer P}` ? P : never
type pathsByMethod<M extends method> = pathByMethod<methodPathsByMethod<M>>

const hasApiRequest = <PM extends keyof apiSchemaCollection>(args: unknown): args is { data: apiSchemaCollection[PM]["Request"] } => {
  return !!(args as { data: unknown })?.data
}

{{- with .BuiltPaths }}
const apiPathBuilder = {
{{- range . }}
  {{ . }},
{{- end }}
} as const

const hasApiPathBuilder = (path: string): path is keyof typeof apiPathBuilder => path in apiPathBuilder
type apiPathBuilderArgs<K extends keyof apiSchemaCollection> = K extends `${method} ${infer P}` ? (P extends keyof typeof apiPathBuilder ? Parameters<typeof apiPathBuilder[P]>[0] : never) : never

const hasApiPathArgs = <PM extends keyof apiSchemaCollection>(args: unknown): args is { pathArgs: apiPathBuilderArgs<PM> } => {
  return !!(args as { pathArgs: unknown })?.pathArgs
}

type pathCallArgs<PM extends keyof apiSchemaCollection> =
  apiSchemaCollection[PM]["Request"] extends undefined ?
  apiPathBuilderArgs<PM> extends undefined ? undefined : { pathArgs: apiPathBuilderArgs<PM> }
  : apiPathBuilderArgs<PM> extends undefined ? { data: apiSchemaCollection[PM]["Request"] } : { data: apiSchemaCollection[PM]["Request"], pathArgs: apiPathBuilderArgs<PM> }
{{- else }}
type pathCallArgs<PM extends keyof apiSchemaCollection> =
  apiSchemaCollection[PM]["Request"] extends undefined ? void : { data: apiSchemaCollection[PM]["Request"] }
{{- end }}

type client = {
{{- range .Methods }}
  {{ .Lower }}: <P extends pathsByMethod<"{{ .Upper }}">>(path: P, args: pathCallArgs<`{{ .Upper }} ${P}`>) => Promise<apiSchemaCollection[`{{ .Upper }} ${P}`]["Response"]>
{{- end }}
}

export const newClient = (baseURL: string = ""): client => {
  const fetchByPath = async <PM extends keyof apiSchemaCollection>(method: method, path: string, args: pathCallArgs<PM>) => {
{{- with .BuiltPaths }}
    const builtPath = hasApiPathBuilder(path) && hasApiPathArgs(args) ? apiPathBuilder[path](args.pathArgs) : path
{{- else }}
    const builtPath = path
{{- end }}
    const body = hasApiRequest(args) ? JSON.stringify(args.data) : undefined
    const response = await fetch(baseURL + builtPath, {
      method,
      headers: {
        "Content-Type": "application/json",
      },
      body,
    })

    if (!response.ok) {
      throw new Error(response.statusText)
    }
    return response.json() as Promise<apiSchemaCollection[PM]["Response"]>
  }

{{- range .Methods }}
  const {{ .Lower }} = async <P extends pathsByMethod<"{{ .Upper }}">>(path: P, args: pathCallArgs<`{{ .Upper }} ${P}`>) => await fetchByPath("{{ .Upper }}", path, args)
{{- end }}

  return {
{{- range .Methods }}
    {{ .Lower }},
{{- end }}
  }
}
