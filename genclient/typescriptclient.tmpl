// This file was automatically @generated by gentypescript

type apiSchemaCollection = {
{{- range . }}
  "{{ .MethodPath }}": {
    Query: {{ .Query.RenderRequest "    " }}
    Request: {{ .Request.RenderRequest "    " }}
    Response: {{ .Response.RenderResponse "    " }} | { error: { message: string } }
  };
{{- end }}
}

export const isErrorResponse = (response: unknown): response is { error: { message: string } } => {
  return !!((response as { error: unknown })?.error)
}

type method = keyof apiSchemaCollection extends `${infer M} ${string}` ? M : never;
type methodPathsByMethod<M extends method> = Extract<keyof apiSchemaCollection, `${M} ${string}`>
type pathByMethod<MP extends string> = MP extends `${method} ${infer P}` ? P : never
type pathsByMethod<M extends method> = pathByMethod<methodPathsByMethod<M>>

const hasApiRequest = <PM extends keyof apiSchemaCollection>(args: unknown): args is { data: apiSchemaCollection[PM]["Request"] } => {
  return !!(args as { data: unknown })?.data
}

const hasApiQuery = <PM extends keyof apiSchemaCollection>(args: unknown): args is { query: apiSchemaCollection[PM]["Query"] } => {
  return !!(args as { query: unknown })?.query
}

{{- with .BuiltPaths }}
const apiPathBuilder = {
{{- range . }}
  {{ . }},
{{- end }}
} as const

const hasApiPathBuilder = (path: string): path is keyof typeof apiPathBuilder => path in apiPathBuilder
type apiPathBuilderArgs<PM extends keyof apiSchemaCollection> =
	PM extends `${method} ${infer P}`
		? P extends keyof typeof apiPathBuilder
			? apiPathBuilderArgsByPath<P>
			: never
		: never;
type apiPathBuilderArgsByPath<K extends keyof typeof apiPathBuilder> =
	Parameters<(typeof apiPathBuilder)[K]>[0];

const pathBuilderByPath = <P extends keyof typeof apiPathBuilder>(
	path: P,
): ((args: apiPathBuilderArgsByPath<P>) => string) => {
	const builder: unknown = apiPathBuilder[path];
	return builder as (args: apiPathBuilderArgsByPath<P>) => string;
};

const hasApiPathArgs = <PM extends keyof apiSchemaCollection>(args: unknown): args is { pathArgs: apiPathBuilderArgs<PM> } => {
  return !!(args as { pathArgs: unknown })?.pathArgs
}

type pathCallArgs<PM extends keyof apiSchemaCollection> =
  apiSchemaCollection[PM]["Request"] extends undefined
    ? // if Request is undefined
      apiSchemaCollection[PM]["Query"] extends undefined
      ? // if Query is undefined
        apiPathBuilderArgs<PM> extends never
        ? Record<string, never>
        : { pathArgs: apiPathBuilderArgs<PM> }
      : // if Query is defined
        apiPathBuilderArgs<PM> extends never
        ? { query: apiSchemaCollection[PM]["Query"] }
        : {
            query: apiSchemaCollection[PM]["Query"];
            pathArgs: apiPathBuilderArgs<PM>;
          }
    : // if Request is defined
      apiSchemaCollection[PM]["Query"] extends undefined
      ? // if Query is undefined
        apiPathBuilderArgs<PM> extends never
        ? { data: apiSchemaCollection[PM]["Request"] }
        : {
            data: apiSchemaCollection[PM]["Request"];
            pathArgs: apiPathBuilderArgs<PM>;
          }
      : // if Query is defined
        apiPathBuilderArgs<PM> extends never
        ? {
            data: apiSchemaCollection[PM]["Request"];
            query: apiSchemaCollection[PM]["Query"];
          }
        : {
            data: apiSchemaCollection[PM]["Request"];
            query: apiSchemaCollection[PM]["Query"];
            pathArgs: apiPathBuilderArgs<PM>;
          };
{{- else }}
type pathCallArgs<PM extends keyof apiSchemaCollection> =
  apiSchemaCollection[PM]["Request"] extends undefined
    ? // if Request is undefined
      apiSchemaCollection[PM]["Query"] extends undefined
      ? // if Query is undefined
        Record<string, never>
      : // if Query is defined
        { query: apiSchemaCollection[PM]["Query"] }
    : // if Request is defined
      apiSchemaCollection[PM]["Query"] extends undefined
      ? // if Query is undefined
        { data: apiSchemaCollection[PM]["Request"] }
      : // if Query is defined
        {
            data: apiSchemaCollection[PM]["Request"];
            query: apiSchemaCollection[PM]["Query"];
        }
{{- end }}

type client = {
{{- range .Methods }}
  {{ .Lower }}: <P extends pathsByMethod<"{{ .Upper }}">>(path: P, args: pathCallArgs<`{{ .Upper }} ${P}`>) => Promise<apiSchemaCollection[`{{ .Upper }} ${P}`]["Response"]>
{{- end }}
}

export const newClient = (baseURL = ""): client => {
  const fetchByPath = async <PM extends keyof apiSchemaCollection>(method: method, path: string, args: pathCallArgs<PM>) => {
{{- with .BuiltPaths }}
    const builtPath = hasApiPathBuilder(path) && hasApiPathArgs(args) ? pathBuilderByPath(path)(args.pathArgs) : path
{{- else }}
    const builtPath = path
{{- end }}
    const query = hasApiQuery(args) ? `?${new URLSearchParams(args.query).toString()}` : ""
    const body = hasApiRequest(args) ? JSON.stringify(args.data) : undefined
    const response = await fetch(baseURL + builtPath + query, {
      method,
      headers: {
        "Content-Type": "application/json",
      },
      body,
    })

    if (!response.ok) {
      throw new Error(response.statusText)
    }
    return response.json() as Promise<apiSchemaCollection[PM]["Response"]>
  }

{{- range .Methods }}
  const {{ .LowerVar }} = async <P extends pathsByMethod<"{{ .Upper }}">>(path: P, args: pathCallArgs<`{{ .Upper }} ${P}`>) => await fetchByPath("{{ .Upper }}", path, args)
{{- end }}

  return {
{{- range .Methods }}
    {{ .LowerReturn }},
{{- end }}
  }
}
